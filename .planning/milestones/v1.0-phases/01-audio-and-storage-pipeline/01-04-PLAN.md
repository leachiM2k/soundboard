---
phase: 01-audio-and-storage-pipeline
plan: "04"
type: execute
wave: 3
depends_on:
  - "01-02"
  - "01-03"
files_modified:
  - src/state/store.ts
  - src/main.ts
autonomous: false
requirements:
  - REC-01
  - REC-02
  - REC-04
  - STOR-01
  - STOR-02
  - STOR-03
  - PLAY-01
  - PLAY-02

must_haves:
  truths:
    - "Tapping an empty slot starts recording; tapping it again stops and saves the audio"
    - "Tapping a filled slot plays back the audio; tapping it again stops and restarts from the beginning"
    - "Microphone permission is requested only on the first tap, not on app load"
    - "Recordings survive a full page reload and appear mapped to their original slot position"
    - "Audio blobs are stored in IndexedDB — no network requests for blob storage"
    - "navigator.storage.persist() is called on first user tap"
    - "Permission denied shows an inline error hint (not toast, not modal)"
    - "Defective blob shows an inline error message and the blob is NOT deleted from IndexedDB"
    - "30s auto-stop saves the recording; 25s warning is visible to the user"
    - "Multiple slots can play audio in parallel (tapping slot 2 while slot 1 plays does not stop slot 1)"
  artifacts:
    - path: "src/state/store.ts"
      provides: "9-slot state machine with TileState enum and transition logic"
      exports: ["TileState", "TileData", "AppState", "createAppState", "transitionTile"]
      min_lines: 80
    - path: "src/main.ts"
      provides: "App bootstrap: loads slots on startup, wires tap handlers to state machine"
      min_lines: 100
  key_links:
    - from: "src/main.ts"
      to: "src/state/store.ts"
      via: "createAppState() called on DOMContentLoaded"
      pattern: "createAppState"
    - from: "src/main.ts"
      to: "src/audio/recorder.ts"
      via: "getMicrophoneStream + startRecording called inside tap handler (user gesture)"
      pattern: "startRecording"
    - from: "src/main.ts"
      to: "src/audio/player.ts"
      via: "ensureAudioContextRunning() called first in every tap handler"
      pattern: "ensureAudioContextRunning"
    - from: "src/main.ts"
      to: "src/storage/db.ts"
      via: "loadAllSlots on boot; saveSlot after recording stops; requestStoragePersistence on first tap"
      pattern: "loadAllSlots|saveSlot|requestStoragePersistence"
---

<objective>
Wire all audio engine modules into a working 9-slot state machine and minimal test harness, then verify the complete pipeline on a real iPhone.

Purpose: This plan closes the loop. The state machine defines the six tile states and valid transitions; main.ts wires it all together. The checkpoint at the end verifies iOS Safari behavior that cannot be tested on desktop — AudioContext unlock, MediaRecorder MIME type, IndexedDB persistence, parallel playback.

Output: `src/state/store.ts` (state machine) and `src/main.ts` (wired harness), plus human verification that the full audio pipeline works on a real iPhone.
</objective>

<execution_context>
@/Users/rotmanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rotmanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-audio-and-storage-pipeline/01-CONTEXT.md
@.planning/phases/01-audio-and-storage-pipeline/01-RESEARCH.md
@.planning/phases/01-audio-and-storage-pipeline/01-01-SUMMARY.md
@.planning/phases/01-audio-and-storage-pipeline/01-02-SUMMARY.md
@.planning/phases/01-audio-and-storage-pipeline/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: 9-slot state machine</name>
  <files>
    src/state/store.ts
  </files>
  <action>
Create `src/state/store.ts` — a typed 9-slot state machine for tile lifecycle management.

**Six tile states:**
- `empty` — no recording, ready to record
- `recording` — MediaRecorder active, mic live
- `saving` — recording stopped, blob being written to IndexedDB
- `has-sound` — recording persisted, ready to play
- `playing` — AudioBufferSourceNode active
- `error` — last operation failed (mic denied, blob defective, etc.)

**Valid transitions:**
- `empty` → `recording` (user taps empty tile, getUserMedia succeeds)
- `empty` → `error` (getUserMedia fails: permission denied, no mic, hardware error)
- `recording` → `saving` (user taps again OR 30s auto-stop fires)
- `saving` → `has-sound` (saveSlot() completes)
- `saving` → `error` (saveSlot() fails — unlikely but possible)
- `has-sound` → `playing` (user taps filled tile)
- `playing` → `has-sound` (audio plays to completion OR user re-taps)
- `has-sound` → `error` (decodeAudioData fails on defective blob)
- `error` → `empty` (user taps tile to retry — for recording errors)
- `error` → `has-sound` (after showing error for defective blob — tile stays has-sound)

```typescript
export type TileState =
  | 'empty'
  | 'recording'
  | 'saving'
  | 'has-sound'
  | 'playing'
  | 'error';

export interface TileData {
  state: TileState;
  /** Present when state is 'recording' — used to stop the active recording session */
  activeRecording?: import('../audio/recorder').ActiveRecording;
  /** Present when state is 'has-sound' or 'playing' — the persisted record */
  record?: import('../storage/db').SlotRecord;
  /** Present when state is 'error' — inline message to show the user */
  errorMessage?: string;
  /** Whether this slot was at 'recording' state when the 25s warning fired */
  warningActive?: boolean;
}

export interface AppState {
  tiles: TileData[];
}

/**
 * Create the initial AppState for 9 tiles.
 * All tiles start as 'empty'. Main.ts will call loadAllSlots() and
 * transition filled tiles to 'has-sound' on boot.
 */
export function createAppState(): AppState {
  return {
    tiles: Array.from({ length: 9 }, (): TileData => ({ state: 'empty' })),
  };
}

/**
 * Transition a tile to a new state, merging in any additional TileData fields.
 * Mutates the AppState in place (simpler than immutable updates for 9 slots).
 * Returns the updated TileData for the given index.
 */
export function transitionTile(
  appState: AppState,
  index: number,
  newState: TileState,
  data: Partial<Omit<TileData, 'state'>> = {},
): TileData {
  const tile = appState.tiles[index];
  if (!tile) throw new RangeError(`Tile index ${index} out of range (0-8)`);

  // Clear fields that don't belong to the new state to avoid stale data
  const next: TileData = { state: newState };
  if (newState === 'recording') {
    next.activeRecording = data.activeRecording;
    next.warningActive = false;
  } else if (newState === 'has-sound' || newState === 'playing') {
    next.record = data.record ?? tile.record;
  } else if (newState === 'error') {
    next.errorMessage = data.errorMessage;
    // Preserve record for 'error' on defective blob (tile stays has-sound conceptually)
    next.record = data.record ?? tile.record;
  }

  appState.tiles[index] = next;
  return next;
}
```

Ensure the file compiles with `strict: true`. No `any` types.
  </action>
  <verify>
Run from /Users/rotmanov/git/private/soundboard:
```bash
npm run build
```
Build must complete with zero TypeScript errors.
  </verify>
  <done>
`npm run build` exits 0. `src/state/store.ts` exists and exports `TileState`, `TileData`, `AppState`, `createAppState`, `transitionTile`. No TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: App bootstrap — wire all modules into working test harness</name>
  <files>
    src/main.ts
  </files>
  <action>
Rewrite `src/main.ts` to wire all modules together into a functional test harness. This is a Phase 1 proof-of-concept harness — no visual polish (Phase 2 replaces the UI). The harness proves the audio pipeline works end-to-end on a real iPhone.

**Bootstrap sequence:**
1. On DOMContentLoaded: call `loadAllSlots()` to restore recordings from IndexedDB
2. For each slot with a saved record: transition tile to `has-sound`
3. Render 9 buttons in `#tiles` — each shows its slot index and current state label
4. Wire tap handlers to the state machine

**Critical tap handler order (must not deviate):**
```
tap handler fires
  → requestStoragePersistence() (first interaction — STOR-03; idempotent, safe to call every time)
  → ensureAudioContextRunning() (MUST be first audio operation — iOS unlock)
  → dispatch based on current tile state
```

**Tap dispatch logic per tile state:**

`empty`:
- Call `getMicrophoneStream()` — this is where the permission prompt fires (REC-04: lazy)
- On success: call `startRecording()`, transition to `recording`
- On error (NotAllowedError): transition to `error`, show inline hint "Mikrofon-Zugriff erforderlich. Tippe erneut zum Wiederholen."
- On other errors: transition to `error`, show "Mikrofon nicht verfügbar."

`recording`:
- Call `tile.activeRecording.stop()` → triggers onComplete callback
- Transition to `saving`
- In onComplete: call `saveSlot(index, result)` → transition to `has-sound`
- If saveSlot fails: transition to `error`, show "Speichern fehlgeschlagen."
- 25s onWarning: set warningActive=true, update button label to show warning (e.g., append " (25s!)")
- 30s auto-stop: same onComplete path as manual stop

`has-sound`:
- Call `playBlob(index, tile.record.blob, onEnded)` — transition to `playing`
- onEnded callback: transition back to `has-sound` (clip played to completion)
- If playBlob throws (defective blob): transition to `error`, show "Wiedergabe fehlgeschlagen. Datei defekt.", KEEP the record (do NOT delete from IndexedDB)

`playing`:
- Call `stopTile(index)` first (clears the active node)
- Then call `playBlob(...)` again to restart from beginning (PLAY-02)

`error` (recording error — tile has no sound, no record):
- Clear error, go back to `empty` flow (call getMicrophoneStream again on next tap)
- On this tap: transition to `empty` and immediately retry recording

`error` (playback error — tile has a record, it's just defective):
- The tile stays in `error` state showing the message (no-op on tap)
- User can re-record via long-press in Phase 2; Phase 1 harness leaves it as-is

`saving`:
- No-op (tap while saving is in progress — ignore)

**DOM rendering:**
For each tile button:
- data attribute: `data-slot="${index}"`
- Text content: `Slot ${index}: ${tile.state}` (minimal, functional label)
- During `recording` with `warningActive`: append " (25s!)" to label
- Error state: show error message as button text below state label

**Inline error display:**
Show errors in the tile button itself (update its text content) — not in `#error-hint`. Per CONTEXT.md: inline hint on screen, not toast, not modal. Error message remains visible until user taps the tile again.

**navigator.storage.persist() timing:**
Call `requestStoragePersistence()` at the top of every tap handler. It is idempotent (guarded by `persistenceRequested` flag in db.ts) — calling it on every tap has no overhead after the first call. This satisfies STOR-03 without requiring a separate "first interaction" detection mechanism.

Implement `renderTiles(appState)` function that clears and redraws the `#tiles` div, called after every state transition. Keep this synchronous and simple.

The complete `src/main.ts` must:
- Import from all four modules: `./audio/format`, `./audio/recorder`, `./audio/player`, `./storage/db`, `./state/store`
- Have zero TypeScript errors
- Have no `any` types
- Be self-contained — Phase 2 will replace this file entirely

Example structure (not exhaustive — implement all cases):

```typescript
import { RECORDING_MIME_TYPE } from './audio/format';
import { getMicrophoneStream, startRecording } from './audio/recorder';
import { ensureAudioContextRunning, playBlob, stopTile, clearAudioCache } from './audio/player';
import { loadAllSlots, saveSlot, SlotIndex, requestStoragePersistence } from './storage/db';
import { createAppState, transitionTile, AppState } from './state/store';

const appState: AppState = createAppState();

function renderTiles(state: AppState): void {
  const container = document.getElementById('tiles');
  if (!container) return;
  container.innerHTML = '';
  state.tiles.forEach((tile, index) => {
    const btn = document.createElement('button');
    btn.dataset.slot = String(index);
    let label = `Slot ${index}: ${tile.state}`;
    if (tile.state === 'recording' && tile.warningActive) label += ' (25s!)';
    if (tile.state === 'error' && tile.errorMessage) label += `\n${tile.errorMessage}`;
    btn.textContent = label;
    btn.addEventListener('click', () => handleTileTap(index as SlotIndex));
    container.appendChild(btn);
  });
}

async function handleTileTap(index: SlotIndex): Promise<void> {
  await requestStoragePersistence(); // STOR-03: first interaction (idempotent)
  await ensureAudioContextRunning(); // iOS AudioContext unlock (MUST be first audio op)

  const tile = appState.tiles[index];

  // ... implement all state cases per the plan above ...
}

document.addEventListener('DOMContentLoaded', async () => {
  const slots = await loadAllSlots();
  slots.forEach((record, index) => {
    if (record) {
      transitionTile(appState, index, 'has-sound', { record });
    }
  });
  renderTiles(appState);
  // Log detected MIME type for debugging on device
  console.log('Detected recording MIME type:', RECORDING_MIME_TYPE || '(browser default)');
});
```

Complete all state dispatch cases. Use `console.error()` for unexpected errors. No `alert()` calls. No `any` types.
  </action>
  <verify>
Run from /Users/rotmanov/git/private/soundboard:
```bash
npm run build
```
Build must complete with zero TypeScript errors. Then start the dev server:
```bash
npm run dev
```
Dev server must start and report a local URL. Open the URL in a desktop browser and confirm 9 buttons render with "Slot N: empty" labels and no console errors.
  </verify>
  <done>
`npm run build` exits 0. `npm run dev` starts without errors. A desktop browser shows 9 buttons labeled "Slot 0: empty" through "Slot 8: empty" with no console errors. All state dispatch paths for the 6 tile states are implemented with no TypeScript errors.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: iPhone Safari pipeline verification</name>
  <action>
Human verifies the complete audio pipeline on a real iPhone running Safari.

Run the dev server with network access:
```bash
npm run dev -- --host
```

Open the Network URL (e.g., http://192.168.x.x:5173) in iPhone Safari. Run the 7 tests in the how-to-verify section below. Report results.
  </action>
  <verify>
All 7 iPhone Safari tests pass:
1. No permission prompt on load (REC-04)
2. Record and save survives page reload (REC-01, REC-02, STOR-01, STOR-02)
3. Playback works and re-tap restarts (PLAY-01, PLAY-02)
4. Parallel playback — two tiles play simultaneously
5. 25s warning fires, 30s auto-stop saves
6. No errors from requestStoragePersistence in console
7. Inline error hint on permission denied (not toast)
  </verify>
  <done>
All 7 tests pass on a real iPhone running Safari. No crashes, no silent failures, no TypeScript errors.
  </done>
  <what-built>
Complete audio and storage pipeline: format detection, idb-keyval storage, MediaRecorder recorder, Web Audio player, 9-slot state machine, and wired test harness running in Vite dev server.

The harness shows 9 clickable buttons. Each button's label shows its current state (empty → recording → saving → has-sound → playing → error).
  </what-built>
  <how-to-verify>
Test on a REAL iPhone running Safari (not desktop, not iOS Simulator — iOS audio behavior differs).

Get the dev server URL on your local network:
```bash
npm run dev -- --host
```
The output will show a Network URL (e.g., http://192.168.x.x:5173). Open that URL in iPhone Safari.

**Test 1 — Microphone permission (REC-04):**
1. Open the URL. Confirm NO permission prompt fires on load.
2. Tap "Slot 0: empty". Confirm the permission prompt fires now (first tap).
3. Grant permission. Confirm button changes to "Slot 0: recording".

**Test 2 — Record and save (REC-01, REC-02, STOR-01, STOR-02):**
1. With slot 0 recording: speak a short phrase into the mic.
2. Tap "Slot 0: recording" again. Confirm button changes to "Slot 0: saving" then "Slot 0: has-sound".
3. Reload the page completely. Confirm "Slot 0: has-sound" reappears (recording survived reload).

**Test 3 — Playback (PLAY-01, PLAY-02):**
1. Tap "Slot 0: has-sound". Confirm button changes to "Slot 0: playing" and audio plays from the speaker.
2. Tap again while playing. Confirm audio stops and restarts from the beginning.
3. Let clip play to completion. Confirm button returns to "Slot 0: has-sound".

**Test 4 — Parallel playback (locked decision):**
1. Record a short sound to slot 0 AND slot 1 (different sounds if possible).
2. Tap slot 0 to start playing. Immediately tap slot 1.
3. Confirm BOTH sounds play simultaneously (slot 0 is NOT stopped by tapping slot 1).

**Test 5 — 25s warning and 30s auto-stop (locked decisions):**
1. Tap an empty slot. Start recording.
2. Wait 25 seconds. Confirm button label changes (shows "(25s!)" indicator).
3. Wait 5 more seconds. Confirm recording auto-stops and saves (button reaches "has-sound").

**Test 6 — Storage persistence (STOR-03):**
1. After recording to any slot, open Safari DevTools (Mac → Develop menu → your iPhone) and check the console. Look for any errors from `requestStoragePersistence`.

**Test 7 — Permission denied (error handling):**
1. In iPhone Settings > Privacy & Security > Microphone, revoke permission for Safari.
2. Return to Safari, tap an empty slot. Confirm inline error text appears on the button (not a toast, not a modal) — something like "Mikrofon-Zugriff erforderlich."
3. Restore mic permission. Tap the same slot again. Confirm recording restarts.

**Expected results:**
- All 7 tests pass on iPhone Safari
- No "undefined" errors, no crashes, no silent failures
- AudioContext state is "running" after first tap (check in Safari DevTools if available)
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass on iPhone Safari, or describe which tests failed and what behavior you observed (e.g., "Test 3 passed, Test 4 failed — slot 0 stopped when slot 1 was tapped").</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` exits 0 with zero TypeScript errors
2. `npm run dev` starts successfully with a Network URL accessible from iPhone
3. Desktop browser shows 9 buttons with correct initial state labels
4. iPhone Safari: permission prompt fires on first tap (not on load)
5. iPhone Safari: recording starts, saves to IndexedDB, survives page reload
6. iPhone Safari: playback via Web Audio API (not HTMLAudioElement)
7. iPhone Safari: parallel playback confirmed (two tiles play simultaneously)
8. iPhone Safari: 25s warning fires, 30s auto-stop saves the recording
9. iPhone Safari: inline error message on permission denied (not toast)
</verification>

<success_criteria>
- State machine covers all 6 tile states with correct transitions
- main.ts wires all modules: format, recorder, player, storage, state
- ensureAudioContextRunning() is called first in every tap handler
- requestStoragePersistence() is called on first tap (idempotent thereafter)
- getMicrophoneStream() is only called on tap, never on startup
- All 7 iPhone Safari verification tests pass
- No TypeScript errors, no `any` types
</success_criteria>

<output>
After completion, create `.planning/phases/01-audio-and-storage-pipeline/01-04-SUMMARY.md` documenting:
- All state transitions implemented
- iPhone Safari test results (which tests passed/failed)
- Any iOS-specific issues discovered and how they were resolved
- Final file list and export summary for all 6 source files
- Any deviations from the plan
</output>
