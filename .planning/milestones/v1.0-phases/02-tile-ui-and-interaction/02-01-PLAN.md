---
phase: 02-tile-ui-and-interaction
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/db.ts
  - src/state/store.ts
  - src/input/long-press.ts
  - src/ui/haptic.ts
autonomous: true
requirements: [PLAY-03, MGMT-01]

must_haves:
  truths:
    - "SlotRecord has an optional label field — existing records without it read as undefined (no migration needed)"
    - "TileData has an optional label field — state machine carries label through transitions"
    - "attachLongPress returns a cleanup function and cancels on touchmove/touchcancel (iOS-safe)"
    - "triggerHaptic fires iOS switch-input click on iOS, navigator.vibrate(10) on Android, silent no-op elsewhere"
  artifacts:
    - path: "src/storage/db.ts"
      provides: "SlotRecord with label?: string field"
      contains: "label?"
    - path: "src/state/store.ts"
      provides: "TileData with label?: string field"
      contains: "label?"
    - path: "src/input/long-press.ts"
      provides: "attachLongPress(el, onLongPress, thresholdMs=500): () => void"
      exports: ["attachLongPress"]
    - path: "src/ui/haptic.ts"
      provides: "triggerHaptic() — iOS switch trick + Android vibrate + no-op"
      exports: ["triggerHaptic"]
  key_links:
    - from: "src/state/store.ts"
      to: "src/storage/db.ts"
      via: "imports SlotRecord type"
      pattern: "import.*SlotRecord.*from.*db"
    - from: "src/ui/haptic.ts"
      to: "DOM"
      via: "appends hidden switch input to document.body"
      pattern: "_switchEl.*body.appendChild"
---

<objective>
Extend the Phase 1 data types and create two utility modules that all UI plans depend on.

Purpose: No plan can wire haptic feedback or long-press without these primitives. No action sheet or main.ts can handle tile labels without the schema field. Building these first as Wave 1 unlocks parallel execution of Plans 02 and 03.
Output: Updated db.ts + store.ts (label field); new long-press.ts; new haptic.ts.
</objective>

<execution_context>
@/Users/rotmanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rotmanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-tile-ui-and-interaction/02-RESEARCH.md
@.planning/phases/01-audio-and-storage-pipeline/01-04-SUMMARY.md
@src/storage/db.ts
@src/state/store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add label field to SlotRecord and TileData</name>
  <files>src/storage/db.ts, src/state/store.ts</files>
  <action>
    In src/storage/db.ts:
    - Add `label?: string;` to the `SlotRecord` interface after the `recordedAt` field.
    - Add a JSDoc comment: `/** User-customizable tile name. undefined = no label set. */`
    - No other changes — idb-keyval stores plain objects; adding an optional field is backward-compatible; existing records read back without label (undefined).

    In src/state/store.ts:
    - Add `label?: string;` to the `TileData` interface after `warningActive`.
    - Add a JSDoc comment: `/** User-set tile name, synced from SlotRecord.label. */`
    - In `transitionTile()`: when transitioning to 'has-sound' or 'playing', also carry forward `label` from `data.label ?? tile.record?.label`.
      Specifically inside the `else if (newState === 'has-sound' || newState === 'playing')` branch, add:
      `next.label = data.label ?? tile.label;`
    - When transitioning to 'error', also preserve label: `next.label = data.label ?? tile.label;`

    Do NOT change any other logic in either file.
  </action>
  <verify>
    Run: `npx tsc --noEmit` from the project root — must exit 0 with no errors.
    Confirm `SlotRecord` has `label?` field and `TileData` has `label?` field.
  </verify>
  <done>TypeScript compiles clean; SlotRecord and TileData both have `label?: string`; existing Phase 1 behaviour unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Create long-press detector module</name>
  <files>src/input/long-press.ts</files>
  <action>
    Create src/input/long-press.ts (create the src/input/ directory if needed).

    Implement `attachLongPress` exactly per the research pattern:

    ```typescript
    /**
     * Attach an iOS-safe long-press detector to an element.
     * Uses touchstart + setTimeout (500ms default) pattern.
     * contextmenu event is NOT used — it does not fire on iOS Safari.
     *
     * CRITICAL: touchstart listener is { passive: true } — required to avoid iOS scroll delay.
     * CRITICAL: touch-action: none must be set on the element via CSS (not done here).
     *
     * Returns a cleanup function that removes all listeners.
     */
    export function attachLongPress(
      el: HTMLElement,
      onLongPress: () => void,
      thresholdMs = 500,
    ): () => void
    ```

    Implementation details:
    - `start(e)`: if `e instanceof TouchEvent && e.touches.length > 1` return (no pinch handling). Otherwise `timer = setTimeout(() => { timer = null; onLongPress(); }, thresholdMs)`.
    - `cancel()`: if timer !== null, clearTimeout(timer), timer = null.
    - Attach: `touchstart` → start, `{ passive: true }`.
    - Attach: `touchend` → cancel, `touchmove` → cancel, `touchcancel` → cancel.
    - Return cleanup that calls cancel() and removes all 4 listeners.

    No imports needed. Pure TypeScript.

    Also handle the "long-press fires then tap also fires" pitfall (Pitfall 2 from research):
    - Track a `longPressActivated` flag; set to true when the setTimeout fires.
    - In the `touchend` handler: if `longPressActivated`, call `event.preventDefault()` to suppress the synthetic click, then reset `longPressActivated = false`.
    - The touchend handler must NOT be passive (needs to call preventDefault).
    - Update the touchend attachment to not use passive: `el.addEventListener('touchend', onTouchEnd)` (no options = active by default).

    Implementation sketch:
    ```typescript
    let timer: ReturnType<typeof setTimeout> | null = null;
    let longPressActivated = false;

    function start(e: TouchEvent | MouseEvent) {
      if (e instanceof TouchEvent && e.touches.length > 1) return;
      longPressActivated = false;
      timer = setTimeout(() => {
        timer = null;
        longPressActivated = true;
        onLongPress();
      }, thresholdMs);
    }

    function cancel() {
      if (timer !== null) { clearTimeout(timer); timer = null; }
    }

    function onTouchEnd(e: TouchEvent) {
      if (longPressActivated) {
        e.preventDefault(); // suppress synthetic click after long-press
        longPressActivated = false;
      }
      cancel();
    }

    el.addEventListener('touchstart', start, { passive: true });
    el.addEventListener('touchend', onTouchEnd);
    el.addEventListener('touchmove', cancel);
    el.addEventListener('touchcancel', cancel);

    return () => {
      cancel();
      el.removeEventListener('touchstart', start);
      el.removeEventListener('touchend', onTouchEnd);
      el.removeEventListener('touchmove', cancel);
      el.removeEventListener('touchcancel', cancel);
    };
    ```
  </action>
  <verify>
    Run: `npx tsc --noEmit` — must exit 0.
    Confirm src/input/long-press.ts exports `attachLongPress`.
  </verify>
  <done>long-press.ts compiles clean; exports attachLongPress with proper touchstart passive + touchend preventDefault suppression; returns cleanup function.</done>
</task>

<task type="auto">
  <name>Task 3: Create haptic feedback utility module</name>
  <files>src/ui/haptic.ts</files>
  <action>
    Create src/ui/haptic.ts (create the src/ui/ directory if needed).

    Implement the minimal production version of triggerHaptic from the research:

    ```typescript
    /**
     * Trigger native haptic feedback.
     * iOS 17.4+: clicks a hidden <input type="checkbox" switch> element (WebKit switch input).
     *            This triggers the native system haptic. Safe no-op on older iOS.
     * Android:   navigator.vibrate(10) — 10ms vibration.
     * Desktop / unsupported: silent no-op.
     *
     * The hidden input is created once and reused (lazy init).
     * MUST be called inside a user gesture (touchstart/click) — same restriction as AudioContext.
     */

    const _isIOS = /iPhone|iPad|iPod/.test(navigator.userAgent);
    let _switchEl: HTMLInputElement | null = null;

    export function triggerHaptic(): void {
      if (_isIOS) {
        if (!_switchEl) {
          _switchEl = document.createElement('input');
          _switchEl.type = 'checkbox';
          _switchEl.setAttribute('switch', '');
          Object.assign(_switchEl.style, {
            position: 'fixed',
            opacity: '0',
            pointerEvents: 'none',
            width: '0',
            height: '0',
          });
          document.body.appendChild(_switchEl);
        }
        _switchEl.click();
        return;
      }
      navigator.vibrate?.(10);
    }
    ```

    Note: `navigator.vibrate` is typed in the DOM lib. The optional chaining `?.` handles the no-op on iOS/desktop without a type error. If TypeScript complains about `vibrate` not existing on `Navigator`, add a type assertion cast: `(navigator as Navigator & { vibrate?: (pattern: number) => void }).vibrate?.(10);`

    No other exports needed.
  </action>
  <verify>
    Run: `npx tsc --noEmit` — must exit 0.
    Confirm src/ui/haptic.ts exports `triggerHaptic`.
  </verify>
  <done>haptic.ts compiles clean; exports triggerHaptic; uses iOS switch trick + Android vibrate + no-op pattern; lazy-initializes hidden input.</done>
</task>

</tasks>

<verification>
After all 3 tasks:
1. `npx tsc --noEmit` exits 0 — no TypeScript errors across the entire project
2. `src/storage/db.ts` has `label?: string` on SlotRecord
3. `src/state/store.ts` has `label?: string` on TileData and carries it through has-sound/playing transitions
4. `src/input/long-press.ts` exports `attachLongPress` with touchstart passive + touchend preventDefault logic
5. `src/ui/haptic.ts` exports `triggerHaptic` with iOS/Android/no-op branches
6. `npm run build` succeeds (Vite bundles cleanly)
</verification>

<success_criteria>
TypeScript project compiles with zero errors. Four files modified/created with no regressions to Phase 1 audio/storage logic. Foundation types and utilities are ready for Plans 02 and 03 to build the visual layer.
</success_criteria>

<output>
After completion, create `.planning/phases/02-tile-ui-and-interaction/02-01-SUMMARY.md` using the summary template.
</output>
