---
phase: 02-tile-ui-and-interaction
plan: "02"
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - index.html
  - src/style.css
  - src/ui/tile.ts
  - src/ui/grid.ts
autonomous: true
requirements: [GRID-01, GRID-02, REC-03]

must_haves:
  truths:
    - "App shows exactly 9 tiles in a 3x3 grid filling the full viewport with no scrolling on iPhone"
    - "Empty tiles are visually distinct from filled tiles (color + icon change)"
    - "Actively recording tile shows pulsing red glow animation"
    - "Filled tiles display the tile label and a play icon. Duration display is deferred to Plan 03 when durationSeconds is added to SlotRecord."
    - "Playing tiles are visually distinct from has-sound tiles (brightness lift)"
    - "Saving tiles are visually dimmed to signal in-progress state"
  artifacts:
    - path: "index.html"
      provides: "Updated HTML shell with viewport-fit=cover, grid container, two hidden dialogs"
      contains: "viewport-fit=cover"
    - path: "src/style.css"
      provides: "Full tile CSS: grid layout, 100dvh, safe-area-inset, all tile state classes, pulse animation"
      contains: "100dvh"
    - path: "src/ui/tile.ts"
      provides: "TILE_COLORS[], getTileColor(), buildTileElement(), updateTileElement(), buildTileContent()"
      exports: ["TILE_COLORS", "getTileColor", "buildTileElement", "updateTileElement"]
    - path: "src/ui/grid.ts"
      provides: "initGrid(), updateTile(index, tile) â€” replaces renderTiles() pattern from main.ts"
      exports: ["initGrid", "updateTile"]
  key_links:
    - from: "src/ui/grid.ts"
      to: "src/ui/tile.ts"
      via: "imports buildTileElement, updateTileElement"
      pattern: "import.*tile"
    - from: "src/ui/tile.ts"
      to: "src/state/store.ts"
      via: "imports TileData type"
      pattern: "import.*TileData"
    - from: "index.html"
      to: "src/style.css"
      via: "link rel=stylesheet"
      pattern: "link.*style.css"
---

<objective>
Build the complete visual layer: HTML shell update, CSS grid + all tile state styles, and TypeScript tile/grid modules.

Purpose: This plan creates every visual element users see â€” the 3x3 grid, tile appearances per state, pulse animation, and duration display. It runs parallel to Plan 01 (no shared files). Plan 03 depends on this plan's grid DOM structure existing.
Output: index.html (updated), src/style.css (new), src/ui/tile.ts (new), src/ui/grid.ts (new).
</objective>

<execution_context>
@/Users/rotmanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rotmanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-tile-ui-and-interaction/02-RESEARCH.md
@.planning/phases/02-tile-ui-and-interaction/02-CONTEXT.md
@src/state/store.ts
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update index.html and create src/style.css</name>
  <files>index.html, src/style.css</files>
  <action>
    **index.html** â€” replace current content with:
    ```html
    <!doctype html>
    <html lang="en">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
        <title>Soundboard</title>
        <link rel="stylesheet" href="/src/style.css" />
      </head>
      <body>
        <div id="app">
          <div id="grid"></div>
        </div>

        <!-- Action sheet dialog (long-press context menu) -->
        <dialog id="action-sheet" aria-modal="true">
          <div class="action-sheet-content">
            <p class="action-sheet-header" id="action-sheet-header"></p>
            <button class="action-sheet-btn" id="btn-rerecord">Neu aufnehmen</button>
            <button class="action-sheet-btn" id="btn-rename">Umbenennen</button>
            <button class="action-sheet-btn destructive" id="btn-delete">LÃ¶schen</button>
            <button class="action-sheet-btn cancel" id="btn-cancel">Abbrechen</button>
          </div>
        </dialog>

        <!-- Rename dialog -->
        <dialog id="rename-dialog" aria-modal="true">
          <form method="dialog" id="rename-form">
            <p class="rename-title">Kachel umbenennen</p>
            <input type="text" id="rename-input" maxlength="30" placeholder="Name eingebenâ€¦" autocomplete="off" />
            <div class="rename-actions">
              <button type="button" id="rename-cancel">Abbrechen</button>
              <button type="submit">Speichern</button>
            </div>
          </form>
        </dialog>

        <script type="module" src="/src/main.ts"></script>
      </body>
    </html>
    ```

    Key requirements:
    - `viewport-fit=cover` in the meta viewport tag â€” REQUIRED for `env(safe-area-inset-bottom)` to have a non-zero value on iPhone with home bar.
    - `<div id="grid">` â€” the grid container (not `id="tiles"` from Phase 1).
    - Two `<dialog>` elements: `#action-sheet` and `#rename-dialog` â€” must be direct children of `<body>` (not inside `#app`) so they are not affected by the app's `user-select: none` CSS applied to tiles.

    **src/style.css** â€” create with the following CSS, implementing ALL tile states from the research:

    ```css
    /* â”€â”€ Reset & Root â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --gap: 10px;
      --radius: 16px;
    }

    body {
      height: 100dvh;           /* dvh: dynamic viewport height â€” adjusts with iOS address bar */
      overflow: hidden;
      background: #111;
      display: flex;
      flex-direction: column;
      font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
    }

    #app {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;            /* CRITICAL: prevents flex child from overflowing */
    }

    /* â”€â”€ Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: var(--gap);
      padding: var(--gap);
      padding-bottom: calc(var(--gap) + var(--safe-bottom));
      flex: 1;
      min-height: 0;
    }

    /* â”€â”€ Tile Base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .tile {
      position: relative;
      border-radius: var(--radius);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 5px;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      cursor: pointer;
      transition: transform 0.08s ease, filter 0.08s ease, opacity 0.08s ease;
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
    }

    .tile:active {
      transform: scale(0.93);
    }

    /* â”€â”€ Tile States â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .tile--empty {
      background: #2a2a2e;
      border: 1.5px dashed rgba(255, 255, 255, 0.18);
    }

    /* Filled â€” accent color applied via CSS custom property */
    .tile--has-sound {
      background: var(--tile-color, #54a0ff);
      border: none;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.35);
    }

    .tile--playing {
      background: var(--tile-color, #54a0ff);
      border: none;
      filter: brightness(1.2);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }

    .tile--recording {
      background: #1c1c1e;
      border: 2px solid rgba(255, 59, 48, 0.9);
      animation: tile-pulse 1.2s ease-in-out infinite;
    }

    .tile--saving {
      background: #2a2a2e;
      opacity: 0.55;
      filter: brightness(0.75);
    }

    .tile--error {
      background: #2c1a1a;
      border: 1.5px solid rgba(255, 59, 48, 0.5);
    }

    /* â”€â”€ Recording pulse animation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    @keyframes tile-pulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(255, 59, 48, 0.7); }
      50%       { box-shadow: 0 0 0 14px rgba(255, 59, 48, 0); }
    }

    @media (prefers-reduced-motion: reduce) {
      .tile--recording {
        animation: none;
        outline: 3px solid rgba(255, 59, 48, 0.9);
      }
    }

    /* â”€â”€ Tile Content â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .tile-icon {
      font-size: 28px;
      line-height: 1;
      pointer-events: none;
    }

    .tile-icon--saving {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.5);
      letter-spacing: 3px;
    }

    .tile-icon--error {
      font-size: 22px;
      color: rgba(255, 59, 48, 0.9);
    }

    .tile-label {
      font-size: 13px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.85);
      text-align: center;
      max-width: 90%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      pointer-events: none;
      line-height: 1.2;
    }

    .tile-duration {
      font-size: 11px;
      color: rgba(0, 0, 0, 0.6);
      font-variant-numeric: tabular-nums;
      pointer-events: none;
    }

    .tile-elapsed {
      font-size: 18px;
      font-weight: 700;
      color: rgba(255, 59, 48, 0.9);
      font-variant-numeric: tabular-nums;
      pointer-events: none;
    }

    .tile-remaining {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.5);
      font-variant-numeric: tabular-nums;
      pointer-events: none;
    }

    /* â”€â”€ Action Sheet Dialog â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #action-sheet {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      top: auto;
      margin: 0;
      max-width: 100%;
      width: 100%;
      border: none;
      border-radius: 14px 14px 0 0;
      background: #1c1c1e;
      padding: 0;
      padding-bottom: var(--safe-bottom);
      transform: translateY(100%);
      transition: transform 0.28s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #action-sheet[open] {
      transform: translateY(0);
    }

    #action-sheet::backdrop {
      background: rgba(0, 0, 0, 0.5);
    }

    .action-sheet-content {
      display: flex;
      flex-direction: column;
    }

    .action-sheet-header {
      font-size: 13px;
      color: rgba(255, 255, 255, 0.45);
      text-align: center;
      padding: 14px 16px 10px;
      border-bottom: 0.5px solid rgba(255, 255, 255, 0.12);
    }

    .action-sheet-btn {
      display: block;
      width: 100%;
      padding: 17px 16px;
      font-size: 17px;
      font-family: inherit;
      border: none;
      border-top: 0.5px solid rgba(255, 255, 255, 0.1);
      background: transparent;
      color: #fff;
      text-align: center;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .action-sheet-btn:active {
      background: rgba(255, 255, 255, 0.06);
    }

    .action-sheet-btn.destructive {
      color: #ff453a;
    }

    .action-sheet-btn.cancel {
      color: rgba(255, 255, 255, 0.55);
      font-size: 15px;
      padding: 14px 16px;
    }

    /* â”€â”€ Rename Dialog â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #rename-dialog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      margin: 0;
      width: min(320px, 90vw);
      border: none;
      border-radius: 14px;
      background: #2c2c2e;
      padding: 20px;
    }

    #rename-dialog::backdrop {
      background: rgba(0, 0, 0, 0.6);
    }

    .rename-title {
      font-size: 17px;
      font-weight: 600;
      color: #fff;
      text-align: center;
      margin-bottom: 14px;
    }

    #rename-input {
      display: block;
      width: 100%;
      padding: 10px 12px;
      font-size: 16px;
      font-family: inherit;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: #3a3a3c;
      color: #fff;
      outline: none;
      margin-bottom: 14px;
      /* Do NOT set user-select: none here â€” input must be editable */
    }

    #rename-input::placeholder {
      color: rgba(255, 255, 255, 0.3);
    }

    .rename-actions {
      display: flex;
      gap: 10px;
    }

    .rename-actions button {
      flex: 1;
      padding: 11px 10px;
      font-size: 16px;
      font-family: inherit;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .rename-actions button[type="button"] {
      background: #3a3a3c;
      color: rgba(255, 255, 255, 0.7);
    }

    .rename-actions button[type="submit"] {
      background: #0a84ff;
      color: #fff;
      font-weight: 600;
    }
    ```

    Note on dialog positioning: The action-sheet `<dialog>` uses `position: fixed` + `bottom: 0` with `transform: translateY(100%)` as the hidden state and `transform: translateY(0)` when `[open]`. This avoids the `display:none` transition pitfall (Pitfall 3 from research). The rename dialog uses `translate(-50%, -50%)` for centering â€” this overrides the browser's default `<dialog>` centering margin.
  </action>
  <verify>
    Run: `npm run build` â€” Vite must bundle successfully with no errors.
    Visually confirm: open `npm run dev` and check that the page shows a dark background (no broken layout). The grid container is empty at this stage (no tile elements yet â€” grid.ts not wired).
  </verify>
  <done>index.html has viewport-fit=cover, #grid container, and both dialog elements. src/style.css exists with all tile state classes, pulse animation, action sheet, and rename dialog styles. Build succeeds.</done>
</task>

<task type="auto">
  <name>Task 2: Create tile.ts and grid.ts UI modules</name>
  <files>src/ui/tile.ts, src/ui/grid.ts</files>
  <action>
    **src/ui/tile.ts** â€” Create with the following:

    ```typescript
    import type { TileData } from '../state/store';

    /** 9 distinct accent colors â€” one per slot index. Bold, playful, classic soundboard palette. */
    export const TILE_COLORS: readonly string[] = [
      '#FF6B6B', // coral red
      '#FF9F43', // warm orange
      '#FECA57', // sunshine yellow
      '#48DBFB', // sky blue
      '#1DD1A1', // mint green
      '#FF9FF3', // soft pink
      '#54A0FF', // vivid blue
      '#5F27CD', // purple
      '#00D2D3', // teal
    ] as const;

    export function getTileColor(index: number): string {
      return TILE_COLORS[index % TILE_COLORS.length] as string;
    }

    /**
     * Format seconds as M:SS (e.g., 0:03, 1:30).
     * Used for tile duration display and action sheet header.
     */
    export function formatDuration(seconds: number): string {
      const m = Math.floor(seconds / 60);
      const s = Math.floor(seconds % 60);
      return `${m}:${s.toString().padStart(2, '0')}`;
    }

    /**
     * Escape HTML to prevent XSS from user-supplied tile labels.
     */
    function escapeHtml(str: string): string {
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    }

    /**
     * Build the inner HTML content string for a tile based on its state.
     * Called by updateTileElement to set tile innerHTML.
     */
    export function buildTileContent(index: number, tile: TileData): string {
      switch (tile.state) {
        case 'empty':
          return '<span class="tile-icon">ðŸŽ™</span>';

        case 'recording':
          return `
            <span class="tile-elapsed" id="timer-elapsed-${index}">0:00</span>
            <span class="tile-remaining" id="timer-remaining-${index}">0:30</span>
          `;

        case 'saving':
          return '<span class="tile-icon tile-icon--saving">Â·Â·Â·</span>';

        case 'has-sound': {
          const label = tile.label ?? `Slot ${index + 1}`;
          // recordedAt is a timestamp; derive duration from record if available
          // Phase 1 stored recordedAt as Date.now() at save time, not as elapsed seconds.
          // We don't have duration in SlotRecord yet â€” show a placeholder.
          // Duration display requires elapsed seconds, which is not in the current SlotRecord schema.
          // Store duration seconds in SlotRecord in a future plan; for now show label only.
          // Note: The record.recordedAt field is a Unix timestamp, not elapsed duration.
          // We'll use a duration field added to SlotRecord in a future enhancement.
          // For Phase 2, show label + a formatted duration if tile.record has a durationSeconds field,
          // otherwise just show the label. The action sheet can show "Tile N" without duration.
          const durDisplay = (tile.record as { durationSeconds?: number } & typeof tile.record)?.durationSeconds != null
            ? formatDuration((tile.record as { durationSeconds?: number } & typeof tile.record).durationSeconds!)
            : '';
          return `
            <span class="tile-icon">â–¶</span>
            <span class="tile-label">${escapeHtml(label)}</span>
            ${durDisplay ? `<span class="tile-duration">${durDisplay}</span>` : ''}
          `;
        }

        case 'playing': {
          const label = tile.label ?? `Slot ${index + 1}`;
          return `
            <span class="tile-icon">â–¶</span>
            <span class="tile-label">${escapeHtml(label)}</span>
          `;
        }

        case 'error':
          return '<span class="tile-icon tile-icon--error">!</span>';

        default: {
          const _exhaustive: never = tile.state;
          console.error('Unknown tile state in buildTileContent:', _exhaustive);
          return '';
        }
      }
    }

    /**
     * Create a fresh tile DOM element for a given slot index.
     * The element is a <div> with data-slot attribute and initial state classes.
     * Event listeners (tap, long-press) are attached by grid.ts, not here.
     */
    export function buildTileElement(index: number, tile: TileData): HTMLDivElement {
      const el = document.createElement('div');
      el.dataset.slot = String(index);
      el.className = 'tile';
      applyTileState(el, index, tile);
      return el;
    }

    /**
     * Update an existing tile element in place without recreating it.
     * Preserves event listeners attached by grid.ts.
     */
    export function updateTileElement(index: number, tile: TileData): void {
      const el = document.querySelector(`[data-slot="${index}"]`) as HTMLElement | null;
      if (!el) return;
      applyTileState(el, index, tile);
    }

    function applyTileState(el: HTMLElement, index: number, tile: TileData): void {
      // Remove all state modifier classes
      el.className = 'tile';
      // Add state-specific modifier class (CSS uses tile-- prefix)
      const cssState = tile.state === 'has-sound' ? 'has-sound' : tile.state;
      el.classList.add(`tile--${cssState}`);

      // Apply accent color for filled and playing states
      if (tile.state === 'has-sound' || tile.state === 'playing') {
        el.style.setProperty('--tile-color', getTileColor(index));
      } else {
        el.style.removeProperty('--tile-color');
      }

      // Set inner content
      el.innerHTML = buildTileContent(index, tile);
    }
    ```

    **Important note on durationSeconds:** The current `SlotRecord` in `db.ts` does not have a `durationSeconds` field â€” only `recordedAt` (a Unix timestamp). Rather than attempting to derive duration from a timestamp (unreliable), the `buildTileContent` for `has-sound` should simply show the tile label without a duration. Add a TODO comment: "Duration display requires durationSeconds field on SlotRecord â€” add in main.ts onComplete callback." This avoids over-engineering now.

    Simplify the `has-sound` case to:
    ```typescript
    case 'has-sound': {
      const label = tile.label ?? `Slot ${index + 1}`;
      return `
        <span class="tile-icon">â–¶</span>
        <span class="tile-label">${escapeHtml(label)}</span>
      `;
    }
    ```

    **src/ui/grid.ts** â€” Create with the following:

    ```typescript
    import type { AppState, TileData } from '../state/store';
    import { buildTileElement, updateTileElement } from './tile';

    let _initialized = false;

    /**
     * Initialize the grid: create all 9 tile elements and append to #grid.
     * Call once on DOMContentLoaded. Use updateTile() for subsequent updates.
     */
    export function initGrid(
      state: AppState,
      onTileTap: (index: number) => void,
      onTileLongPress: (index: number) => void,
    ): void {
      const grid = document.getElementById('grid');
      if (!grid) throw new Error('Grid container #grid not found in DOM');
      if (_initialized) {
        console.warn('initGrid called more than once â€” ignored');
        return;
      }
      _initialized = true;

      grid.innerHTML = '';

      state.tiles.forEach((tile, index) => {
        const el = buildTileElement(index, tile);

        // Tap handler â€” click event fires reliably on both mouse and touch
        el.addEventListener('click', () => onTileTap(index));

        // Long-press handler â€” attached by main.ts via attachLongPress after initGrid
        // Store a reference so main.ts can attach long-press after the element is created.
        // We expose the element via the data-slot attribute for querySelector access.
        // (main.ts will call attachLongPress on each element after initGrid returns)

        grid.appendChild(el);
      });
    }

    /**
     * Update a single tile's visual state without recreating it.
     * Preserves event listeners. Call after every transitionTile().
     */
    export function updateTile(index: number, tile: TileData): void {
      updateTileElement(index, tile);
    }

    /**
     * Update all 9 tiles at once. Use after bulk state changes (e.g., initial load).
     */
    export function updateAllTiles(state: AppState): void {
      state.tiles.forEach((tile, index) => updateTileElement(index, tile));
    }
    ```

    Note on long-press attachment: `initGrid` takes tap and long-press callbacks but attaches only the click handler directly. The comment instructs main.ts to call `attachLongPress` after `initGrid`. This keeps grid.ts free of imports from input/long-press.ts and lets main.ts control the complete event wiring.

    Alternative (simpler): Have `initGrid` accept an optional `onLongPress` callback and let it call `attachLongPress` internally. This requires grid.ts to import long-press.ts. This is fine â€” do this instead:

    In the final implementation, import `attachLongPress` in grid.ts and wire it inside `initGrid`:

    ```typescript
    import { attachLongPress } from '../input/long-press';

    // inside forEach:
    const cleanup = attachLongPress(el, () => onTileLongPress(index));
    // Store cleanup per-element if we ever need to detach (Phase 3 â€” not needed now)
    void cleanup; // suppress unused variable warning
    ```

    This is cleaner than requiring main.ts to iterate elements again. Use this approach.
  </action>
  <verify>
    Run: `npx tsc --noEmit` â€” must exit 0.
    Run: `npm run build` â€” Vite must bundle cleanly.
    Both src/ui/tile.ts and src/ui/grid.ts must exist with their exported functions.
  </verify>
  <done>tile.ts exports TILE_COLORS, getTileColor, formatDuration, buildTileContent, buildTileElement, updateTileElement. grid.ts exports initGrid, updateTile, updateAllTiles. TypeScript compiles clean. Build succeeds.</done>
</task>

</tasks>

<verification>
After all tasks:
1. `index.html` has `viewport-fit=cover` in the meta viewport tag
2. `index.html` has `<div id="grid">` and both `<dialog id="action-sheet">` and `<dialog id="rename-dialog">`
3. `src/style.css` has `height: 100dvh` on body, `#grid` with CSS Grid layout, `padding-bottom: calc(var(--gap) + var(--safe-bottom))`, and all `.tile--*` state classes
4. `@keyframes tile-pulse` is defined and used in `.tile--recording`
5. `npx tsc --noEmit` exits 0
6. `npm run build` succeeds
</verification>

<success_criteria>
HTML, CSS, and TypeScript visual layer complete. Grid container in DOM. All tile state classes defined. Pulse animation ready. tile.ts and grid.ts modules export correct API for Plan 03 to wire into main.ts. No regressions to Phase 1 audio modules.
</success_criteria>

<output>
After completion, create `.planning/phases/02-tile-ui-and-interaction/02-02-SUMMARY.md` using the summary template.
</output>
