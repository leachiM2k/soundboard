---
phase: 05-visual-feedback
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ui/viz-recording.ts
  - src/style.css
  - src/main.ts
autonomous: true
requirements:
  - VIZ-01

must_haves:
  truths:
    - "During recording, 12 frequency bars animate inside the recording tile canvas at up to 30fps, visibly reacting to microphone input"
    - "When recording ends (manual tap, auto-stop at 30s, or error), the canvas and rAF loop are both cleaned up — no bars left on the saving tile"
    - "No speaker feedback occurs during recording — the AnalyserNode is connected to the stream source but NOT to ctx.destination"
    - "On iOS 14.x the bars render without error (fillRect used, not roundRect)"
  artifacts:
    - path: "src/ui/viz-recording.ts"
      provides: "startRecordingViz(index, stream) / stopRecordingViz(index) — AnalyserNode + canvas rAF loop"
      exports: ["startRecordingViz", "stopRecordingViz"]
    - path: "src/style.css"
      provides: ".tile-viz-canvas CSS rule (position absolute, inset 0, pointer-events none)"
      contains: ".tile-viz-canvas"
    - path: "src/main.ts"
      provides: "viz start/stop wired into all 3 recording paths (empty->recording, recording->manual stop, onComplete)"
  key_links:
    - from: "src/main.ts (empty case)"
      to: "src/ui/viz-recording.ts"
      via: "startRecordingViz(index, stream) called after startRecording() returns"
      pattern: "startRecordingViz"
    - from: "src/main.ts (recording case manual stop)"
      to: "src/ui/viz-recording.ts"
      via: "stopRecordingViz(index) called before current.activeRecording?.stop()"
      pattern: "stopRecordingViz"
    - from: "src/main.ts (onComplete callback)"
      to: "src/ui/viz-recording.ts"
      via: "stopRecordingViz(index) called at the start of onComplete, before stopRecordingTimer()"
      pattern: "stopRecordingViz"
---

<objective>
Implement VIZ-01: real-time frequency bar visualizer during recording.

Purpose: Users see live proof the microphone is active — 12 animated bars inside the recording tile confirm the mic is capturing audio. This is the primary trust signal during recording.

Output: `src/ui/viz-recording.ts` (standalone module with clean start/stop API), CSS overlay rule, and `main.ts` integration covering all 3 recording stop paths.
</objective>

<execution_context>
@/Users/rotmanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rotmanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-visual-feedback/05-RESEARCH.md

# Source files to modify
@src/main.ts
@src/style.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create viz-recording.ts — AnalyserNode frequency bar module</name>
  <files>src/ui/viz-recording.ts</files>
  <action>
    Create `src/ui/viz-recording.ts` implementing the recording visualizer with a clean start/stop API.

    Follow Pattern 1 from the RESEARCH.md exactly. Key implementation rules:

    1. Import `getAudioContext` from `'../audio/player'` (shared singleton — never create a new AudioContext).

    2. `startRecordingViz(index: number, stream: MediaStream): void`
       - Call `stopRecordingViz(index)` first (idempotent — clears any leftover from prior recording on same tile)
       - Create `AnalyserNode` via `ctx.createAnalyser()` with `fftSize = 64`, `smoothingTimeConstant = 0.75`
       - Create `MediaStreamAudioSourceNode` via `ctx.createMediaStreamSource(stream)`
       - Connect: `source.connect(analyser)` — DO NOT call `analyser.connect(ctx.destination)` (would route mic to speakers on iOS)
       - Create a `<canvas>` element with `className = 'tile-viz-canvas'` and `aria-hidden = 'true'`
       - Find tile element via `document.querySelector('[data-slot="${index}"]') as HTMLElement | null` — return early if null
       - Append canvas to tile element
       - Set `canvas.width` and `canvas.height` from `tileEl.getBoundingClientRect()` (integer px values via `Math.round`) — do NOT set via CSS only or drawing buffer will be 300x150
       - rAF draw loop: cap at 30fps using `TARGET_INTERVAL_MS = 1000 / 30` and timestamp delta guard (`if (timestamp - lastFrameTime < TARGET_INTERVAL_MS) return`)
       - Inside draw: call `analyser.getByteFrequencyData(dataArray)` — use `Uint8Array(analyser.frequencyBinCount)` — NOT `getFloatTimeDomainData` (missing on Safari)
       - Draw 12 bars: `BAR_COUNT = 12`, `step = Math.floor(bufferLength / BAR_COUNT)`, `barW = Math.floor((canvas.width - 8) / BAR_COUNT) - 2`, `maxH = canvas.height - 8`
       - For each bar: `barH = Math.max(3, Math.round((value / 255) * maxH))`, `x = 4 + i * (barW + 2)`, `y = canvas.height - barH - 4`
       - Fill color: `rgba(255, 255, 255, ${0.4 + (value / 255) * 0.6})`
       - Use `canvasCtx.fillRect(x, y, barW, barH)` — NOT `roundRect` (unavailable on iOS 14.x, project targets iOS 14.3+)
       - Clear canvas each frame with `canvasCtx.clearRect(0, 0, canvas.width, canvas.height)` before drawing bars
       - Store `rafHandle` and cleanup closure in `activeVizMap.set(index, { stop: () => { cancelAnimationFrame(rafHandle); source.disconnect(); analyser.disconnect(); canvas.remove(); } })`

    3. `stopRecordingViz(index: number): void`
       - Look up `activeVizMap.get(index)`, call `.stop()`, then `activeVizMap.delete(index)`
       - Safe to call when no viz is active (no-op)

    4. Module-level: `const activeVizMap = new Map<number, { stop: () => void }>()`

    5. Export both functions.

    iOS safety: The `MediaRecorder` captures audio from the `MediaStream` directly — it does NOT require the Web Audio graph to reach `ctx.destination`. The analyser reads frequency data without forwarding audio to speakers.
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Check that viz-recording.ts has no TS errors and exports startRecordingViz and stopRecordingViz</manual>
  </verify>
  <done>
    `src/ui/viz-recording.ts` compiles cleanly. Exports `startRecordingViz` and `stopRecordingViz`. No TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CSS overlay rule + wire viz into main.ts recording paths</name>
  <files>src/style.css, src/main.ts</files>
  <action>
    **Part A — src/style.css:**

    Add the following CSS rule at the end of the file (after existing rules). The tile already has `position: relative; overflow: hidden` — the canvas must be `position: absolute` to overlay tile content:

    ```css
    /* VIZ-01: Frequency bar canvas overlay during recording */
    .tile-viz-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      border-radius: var(--radius, 16px);
    }
    ```

    **Part B — src/main.ts:**

    Add import at top of file alongside other UI imports:
    ```typescript
    import { startRecordingViz, stopRecordingViz } from './ui/viz-recording';
    ```

    Wire `startRecordingViz` and `stopRecordingViz` into the 3 recording paths:

    **Path 1 — `empty` case, after `startRecording()` returns and before `transitionTile(..., 'recording', ...):`**
    Call `startRecordingViz(index, stream)` — stream is already in scope from `getMicrophoneStream()`.
    Insert it after `const activeRecording = startRecording(...)` call and before `void acquireWakeLock()`.

    **Path 2 — `onComplete` callback (inside `startRecording` call), at the very start of the callback (before `void releaseWakeLock()` and `stopRecordingTimer()`):**
    Call `stopRecordingViz(index)` — this covers both the auto-stop (30s timer) and the manual stop path because `onComplete` fires in both cases via `recorder.onstop`.

    **Path 3 — `recording` case (manual tap to stop), before `current.activeRecording?.stop()`:**
    Call `stopRecordingViz(index)` — this ensures the canvas is removed before the tile transitions to saving, even in the brief window before `onComplete` fires.

    Note on Path 2 vs Path 3: Path 3 fires synchronously on manual stop before `onComplete`. Path 2 (`onComplete`) fires after the MediaRecorder `onstop` event. Both must call `stopRecordingViz` to handle the idempotent cleanup correctly (second call is a no-op because `activeVizMap.delete` removes the entry).

    Do NOT add viz calls to error paths or saving paths — those are not recording states.
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>
      1. Run `npm run dev`, open in browser
      2. Tap an empty tile to start recording — frequency bars should appear overlaying the tile
      3. Tap again to stop recording — bars should disappear as tile transitions to saving
      4. Check browser console for any errors
    </manual>
  </verify>
  <done>
    TypeScript compiles cleanly. `.tile-viz-canvas` CSS rule exists in style.css. `main.ts` imports `startRecordingViz` and `stopRecordingViz` and calls them in all 3 recording paths. `npx tsc --noEmit` exits 0.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `npx tsc --noEmit` exits 0 — no TypeScript errors
2. `grep -n 'startRecordingViz\|stopRecordingViz' src/main.ts` shows 3 call sites: one start (empty case) and two stops (onComplete and recording case)
3. `grep -n 'tile-viz-canvas' src/style.css` returns the CSS rule
4. `grep -n 'roundRect' src/ui/viz-recording.ts` returns nothing — fillRect used exclusively
5. `grep -n 'destination' src/ui/viz-recording.ts` returns nothing — no connection to ctx.destination
</verification>

<success_criteria>
- `src/ui/viz-recording.ts` exists with `startRecordingViz` and `stopRecordingViz` exports
- `.tile-viz-canvas` CSS rule exists in `src/style.css`
- `main.ts` wires viz into all 3 recording paths (start in empty case, stop in onComplete and recording case)
- TypeScript compiles without errors
- No `roundRect` calls (iOS 14 compatibility)
- No `ctx.destination` connection from AnalyserNode (no iOS speaker feedback)
- `fillRect` used for bar drawing
</success_criteria>

<output>
After completion, create `.planning/phases/05-visual-feedback/05-01-SUMMARY.md` using the summary template at `@/Users/rotmanov/.claude/get-shit-done/templates/summary.md`.

Include in the summary:
- The 3 integration points in main.ts for stopRecordingViz (exact line positions)
- Confirmation that fillRect is used (not roundRect) — iOS 14 safe
- Confirmation that AnalyserNode is NOT connected to ctx.destination — no iOS feedback
</output>
