---
phase: 06-audio-operations
plan: 02
type: execute
wave: 2
depends_on:
  - 06-01
files_modified:
  - src/audio/trim.ts
  - src/ui/toast.ts
  - src/audio/player.ts
  - src/main.ts
  - src/style.css
autonomous: true
requirements:
  - TRIM-01

must_haves:
  truths:
    - "After recording, silence at the start and end of a clip is trimmed automatically; user sees a toast 'Stille entfernt' with an Undo button"
    - "Tapping 'Stille kürzen' in the long-press menu re-applies trim to an already-saved clip; the duration badge reflects the shorter clip"
    - "Tapping Undo in the toast within 5 seconds restores the original duration and removes the trim offsets"
    - "If the clip is entirely silent (no audio above threshold), trim is skipped and a 'Kein Ton gefunden' message is shown"
    - "Playback of a trimmed clip plays only the non-silent portion (silence skipped at start and end)"
  artifacts:
    - path: "src/audio/trim.ts"
      provides: "findTrimOffsets() silence detection; applyTrimToRecord() that updates SlotRecord with trimStartSec/trimEndSec/durationSeconds"
      exports: ["findTrimOffsets", "applyTrimToRecord"]
    - path: "src/ui/toast.ts"
      provides: "showTrimToast(onUndo) ephemeral notification; auto-dismisses after 5s"
      exports: ["showTrimToast"]
    - path: "src/audio/player.ts"
      provides: "playBlob() with optional trimStartSec and trimEndSec params; passes offset+duration to source.start()"
      exports: ["playBlob"]
    - path: "src/main.ts"
      provides: "handleTrim(index) function; onTrim wired in handleLongPress; auto-trim call in onComplete after recording"
  key_links:
    - from: "src/audio/trim.ts"
      to: "src/audio/player.ts"
      via: "AudioBuffer in audioBufferCache used by findTrimOffsets — same cache already populated by playBlob decode"
      pattern: "audioBufferCache"
    - from: "src/main.ts"
      to: "src/audio/trim.ts"
      via: "handleTrim calls applyTrimToRecord then saveSlot then updateTile"
      pattern: "applyTrimToRecord|findTrimOffsets"
    - from: "src/main.ts"
      to: "src/ui/toast.ts"
      via: "handleTrim calls showTrimToast with undo callback"
      pattern: "showTrimToast"
    - from: "src/audio/player.ts"
      to: "AudioBufferSourceNode.start"
      via: "source.start(0, trimStartSec, playDuration)"
      pattern: "source\\.start\\(0"
---

<objective>
Implement TRIM-01: auto-silence trimming via AudioBuffer offset detection, with toast feedback and Undo.

Purpose: After recording (or on demand via action sheet), silence at start/end of the clip is trimmed by storing offset fields in SlotRecord. Playback skips silence via AudioBufferSourceNode.start(offset, duration). The blob in IndexedDB is never modified — trim is lossless and instantly reversible.
Output: src/audio/trim.ts, src/ui/toast.ts (new files); src/audio/player.ts and src/main.ts modified.
</objective>

<execution_context>
@/Users/rotmanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rotmanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/06-audio-operations/06-RESEARCH.md
@.planning/phases/06-audio-operations/06-01-SUMMARY.md

@src/storage/db.ts
@src/audio/player.ts
@src/state/store.ts
@src/main.ts
@src/ui/action-sheet.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/audio/trim.ts — silence detection and trim record update</name>
  <files>src/audio/trim.ts</files>
  <action>
Create new file `src/audio/trim.ts`. This module provides two exports:

**`findTrimOffsets(buf: AudioBuffer, threshold = 0.01)`**

Implement exactly as in the RESEARCH.md code examples section ("Silence Detection"). Key points:
- Walk all channels simultaneously — silence is silence on ALL channels
- Returns `{ startSec: number; endSec: number } | null` — null means entire clip is silent
- Use `startSample = -1` sentinel; if still -1 after scan, return null
- Add 5ms grace margin: `const grace = Math.round(sampleRate * 0.005)`
- `startSec = Math.max(0, startSample - grace) / sampleRate`
- `endSec = Math.min(length - 1, endSample + grace) / sampleRate`
- CRITICAL: getChannelData() returns a live Float32Array view — read-only, never mutate it
- After computing offsets: if `endSec - startSec < 0.1`, return null (clip effectively silent)

**`applyTrimToRecord(record: SlotRecord, startSec: number, endSec: number): SlotRecord`**

Returns a new SlotRecord object (spread, do not mutate) with:
- `trimStartSec: startSec`
- `trimEndSec: endSec`
- `durationSeconds: Math.round(endSec - startSec)` — update badge to show trimmed duration

NOTE: The AudioBuffer cache access (to get the buffer for scanning) is handled in main.ts via the exported `audioBufferCache` map — see Task 3. This module only does the math, not cache access.

Import only SlotRecord from '../storage/db'.

Full module should be ~50 lines.
  </action>
  <verify>
    <automated>cd /Users/rotmanov/git/private/soundboard && npx tsc --noEmit 2>&1</automated>
    <manual>Verify trim.ts exports findTrimOffsets and applyTrimToRecord with correct signatures</manual>
  </verify>
  <done>tsc --noEmit passes; src/audio/trim.ts exists with findTrimOffsets and applyTrimToRecord exports</done>
</task>

<task type="auto">
  <name>Task 2: Create src/ui/toast.ts and update player.ts for trim offset playback</name>
  <files>src/ui/toast.ts, src/audio/player.ts</files>
  <action>
**Create src/ui/toast.ts:**

Implement `showTrimToast(onUndo: () => void): void` following the RESEARCH.md "Trim applied Toast" pattern:
- Remove any existing `.toast` element first (`document.querySelector('.toast')?.remove()`)
- Create a div with `className = 'toast'`
- innerHTML: `<span>Stille entfernt</span><button class="toast-undo">Rückgängig</button>`
- Wire the Undo button: on click, `toast.remove()` then call `onUndo()`
- Append to `document.getElementById('app')!`
- Auto-dismiss: `setTimeout(() => toast.remove(), 5000)`
- Export as named export: `export function showTrimToast(onUndo: () => void): void`

Also add CSS for `.toast` in `src/style.css`:
- Fixed position, bottom center, above safe area: `position: fixed; bottom: calc(env(safe-area-inset-bottom) + 80px); left: 50%; transform: translateX(-50%)`
- Dark background: `background: rgba(30,30,50,0.95); color: #fff; border-radius: 8px; padding: 10px 16px`
- Flex row: `display: flex; align-items: center; gap: 12px; white-space: nowrap`
- `.toast-undo` button: `background: none; border: 1px solid rgba(255,255,255,0.5); color: #fff; border-radius: 6px; padding: 4px 10px; font-size: 0.85rem; cursor: pointer`
- z-index: 200 (above action sheet at z-index ~100)

**Update src/audio/player.ts — add trim offset support:**

Modify `playBlob()` signature to accept two new optional parameters after the existing `onStarted?`:

```typescript
export async function playBlob(
  tileIndex: number,
  blob: Blob,
  onEnded: () => void,
  onStarted?: (startCtxTime: number, durationSec: number) => void,
  trimStartSec = 0,
  trimEndSec?: number,
): Promise<void>
```

Inside `playBlob`, AFTER the `source.buffer = audioBuffer` assignment and BEFORE `source.start(0)`, replace the `source.start(0)` line with:

```typescript
const effectiveEnd = trimEndSec ?? audioBuffer.duration;
const playDuration = effectiveEnd - trimStartSec;
source.start(0, trimStartSec, playDuration);
const startCtxTime = ctx.currentTime;
onStarted?.(startCtxTime, playDuration); // pass trimmed duration, not full duration
```

Remove the original `source.start(0)` and the original `onStarted?.(startCtxTime, audioBuffer.duration)` line.

CRITICAL: The 3-argument form of playBlob (tileIndex, blob, onEnded) and 4-argument form (+ onStarted) must still compile and work identically — trimStartSec defaults to 0 and trimEndSec defaults to undefined (= play to natural end), so trimmed playback equals original when no trim offsets are passed.

Do NOT change any other part of player.ts (stopTile, clearAudioCache, getAudioContext, etc.).
  </action>
  <verify>
    <automated>cd /Users/rotmanov/git/private/soundboard && npx tsc --noEmit 2>&1</automated>
    <manual>Verify player.ts compiles and existing callers in main.ts (4-arg calls) still work; verify toast.ts exists</manual>
  </verify>
  <done>tsc --noEmit passes; playBlob accepts trimStartSec and trimEndSec optional params; showTrimToast exported from ui/toast.ts; existing 4-arg calls to playBlob in main.ts unchanged</done>
</task>

<task type="auto">
  <name>Task 3: Wire trim into main.ts — handleTrim, auto-trim after recording, onTrim in handleLongPress</name>
  <files>src/main.ts, src/ui/toast.ts</files>
  <action>
Make four changes to src/main.ts:

**1. New imports at top of file:**
```typescript
import { findTrimOffsets, applyTrimToRecord } from './audio/trim';
import { showTrimToast } from './ui/toast';
import { audioBufferCache } from './audio/player';
```

IMPORTANT: `audioBufferCache` must be exported from player.ts for this import to work. Add `export` to the `const audioBufferCache` declaration in player.ts if not already exported. This is necessary so trim.ts callers can access the cached AudioBuffer without re-decoding.

**2. New `handleTrim(index: SlotIndex)` async function** (add after `handleColorChange`):

```typescript
async function handleTrim(index: SlotIndex): Promise<void> {
  const tile = appState.tiles[index];
  if (!tile.record) return;

  // Get cached AudioBuffer — populated on first play; if not yet played, decode now
  let audioBuffer = audioBufferCache.get(index);
  if (!audioBuffer) {
    try {
      const arrayBuffer = await tile.record.blob.arrayBuffer();
      const ctx = (await import('./audio/player')).getAudioContext();
      audioBuffer = await ctx.decodeAudioData(arrayBuffer);
      audioBufferCache.set(index, audioBuffer);
    } catch {
      console.error('handleTrim: failed to decode audio for trim');
      return;
    }
  }

  const offsets = findTrimOffsets(audioBuffer);
  if (!offsets) {
    // Entirely silent or no detectable audio
    showTrimToast(() => {}); // show "Kein Ton gefunden" — see note below
    return;
  }

  const originalRecord = tile.record;
  const trimmedRecord = applyTrimToRecord(originalRecord, offsets.startSec, offsets.endSec);

  await saveSlot(index, trimmedRecord);
  tile.record = trimmedRecord;
  updateTile(index, appState.tiles[index]);

  showTrimToast(() => {
    // Undo: restore original record (trim offsets cleared, original duration restored)
    saveSlot(index, originalRecord).catch(console.error);
    tile.record = originalRecord;
    updateTile(index, appState.tiles[index]);
  });
}
```

NOTE on "Kein Ton gefunden": For the entirely-silent case, modify showTrimToast to accept an optional message param, or create a separate `showInfoToast(message: string)` in toast.ts and call it here. The RESEARCH.md specifies showing "Kein Ton gefunden" for this case. Choose the simplest approach: add an optional `message?: string` param to showTrimToast defaulting to `'Stille entfernt'`; the silent case passes `'Kein Ton gefunden'` and no Undo button (pass `null` for onUndo or check onUndo nullable). Adjust toast.ts accordingly — Undo button only rendered when onUndo is a function.

**3. Auto-trim after recording** — inside the `onComplete` callback in the `case 'empty':` block, after the `saveSlot(...).then(...)` success path (after `transitionTile` to `has-sound` and `updateTile`), add an auto-trim call:

```typescript
.then(() => {
  const record = { blob: result.blob, mimeType: result.mimeType, recordedAt: Date.now(), durationSeconds };
  transitionTile(appState, index, 'has-sound', { record });
  updateTile(index, appState.tiles[index]);
  // Auto-trim silence after recording completes
  handleTrim(index).catch((err: unknown) => {
    console.error('Auto-trim error (non-fatal):', err);
  });
})
```

IMPORTANT: Auto-trim is non-blocking (void/catch pattern). A failure must NOT prevent the tile from being usable.

**4. Wire onTrim in handleLongPress** — in the `showActionSheet(...)` call inside `handleLongPress`, add `onTrim` to the callbacks object:

```typescript
onTrim: () => {
  handleTrim(index).catch((err: unknown) => {
    console.error('Trim error:', err);
  });
},
```

Also update the existing playBlob calls in the `case 'has-sound':` and `case 'playing':` blocks to pass trim offsets from the record:

```typescript
// In has-sound case playBlob call:
await playBlob(index, record.blob, () => { ... }, (startCtxTime, durationSec) => { ... },
  record.trimStartSec ?? 0, record.trimEndSec);

// In playing case playBlob call (both the initial and re-tap calls):
await playBlob(index, record.blob, () => { ... }, (startCtxTime, durationSec) => { ... },
  record.trimStartSec ?? 0, record.trimEndSec);
```

CRITICAL: Pass `record.trimStartSec ?? 0` (not just `record.trimStartSec`) and `record.trimEndSec` (undefined = play to end — correct default). This ensures trimmed playback uses the stored offsets; un-trimmed clips play from 0 to natural end unchanged.
  </action>
  <verify>
    <automated>cd /Users/rotmanov/git/private/soundboard && npx tsc --noEmit 2>&1 && npm run build 2>&1 | tail -5</automated>
    <manual>Record a clip, observe auto-trim toast appears; tap "Rückgängig" and verify duration badge reverts; long-press filled tile, tap "Stille kürzen", verify toast and updated duration badge</manual>
  </verify>
  <done>tsc --noEmit passes; npm run build succeeds; auto-trim fires after recording with toast; manual trim available via action sheet; Undo restores original duration; entirely-silent clips show "Kein Ton gefunden" without crash</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm run build` succeeds
- Record a clip: toast "Stille entfernt" appears within 1s after recording completes
- Duration badge on tile updates to trimmed duration
- Tap Undo in toast: duration badge reverts to original; subsequent playback plays the full clip again
- Long-press filled tile → "Stille kürzen": same trim+toast+undo flow applies
- Playback of trimmed clip plays only the non-silent portion (silence skipped at start/end)
- Re-recording a tile clears trim offsets (new saveSlot overwrites entire record — verified in RESEARCH.md Pitfall 7)
</verification>

<success_criteria>
- tsc --noEmit and npm run build both pass
- TRIM-01 fully implemented: auto-trim after recording, manual trim via action sheet, toast with Undo, silent-clip guard
- Existing playback behavior unchanged for un-trimmed clips (trimStartSec=0, trimEndSec=undefined defaults)
- No blob modification in IndexedDB — original audio preserved; trim is purely offset metadata
</success_criteria>

<output>
After completion, create `.planning/phases/06-audio-operations/06-02-SUMMARY.md` using the summary template.
</output>
