---
phase: 01-audio-and-storage-pipeline
plan: "03"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/audio/player.ts
autonomous: true
requirements:
  - PLAY-01
  - PLAY-02

must_haves:
  truths:
    - "getAudioContext() returns a single shared AudioContext (never more than one instance)"
    - "ensureAudioContextRunning() is called at the start of every user tap handler before any audio operation"
    - "playBlob() stops only the current tile's node before starting a new one (parallel playback across tiles is preserved)"
    - "Re-tapping a playing tile stops it and restarts from the beginning (PLAY-02)"
    - "A defective blob that fails decodeAudioData throws (caller shows error, does not delete blob)"
    - "onEnded fires when the clip plays to completion (tile can return to filled/idle state)"
    - "AudioBuffer is cached per slot after first decode to avoid re-decoding on repeated plays"
  artifacts:
    - path: "src/audio/player.ts"
      provides: "AudioContext singleton, playBlob, stopTile, ensureAudioContextRunning"
      exports: ["getAudioContext", "ensureAudioContextRunning", "playBlob", "stopTile", "clearAudioCache"]
      min_lines: 80
  key_links:
    - from: "src/audio/player.ts"
      to: "AudioContext"
      via: "lazy singleton — created on first getAudioContext() call, never on module load"
      pattern: "new AudioContext"
    - from: "src/audio/player.ts"
      to: "AudioBufferSourceNode"
      via: "new node per playback — AudioBufferSourceNode is single-use by design"
      pattern: "createBufferSource"
    - from: "src/audio/player.ts"
      to: "activeNodes Map"
      via: "per-tile tracking enables stop-and-restart and parallel playback across tiles"
      pattern: "activeNodes"
---

<objective>
Build the player module: AudioContext singleton management and per-tile audio playback with iOS Safari guard conditions.

Purpose: The player encapsulates the two hardest iOS Safari constraints — the user-gesture AudioContext unlock requirement and the 4-instance limit. Getting this wrong produces silent failures with no error thrown. The module must be correct before the state machine wires everything together in Plan 04.

Output: `src/audio/player.ts` with the AudioContext singleton, `ensureAudioContextRunning()`, `playBlob()` (with AudioBuffer cache), and `stopTile()`.
</objective>

<execution_context>
@/Users/rotmanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rotmanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-audio-and-storage-pipeline/01-CONTEXT.md
@.planning/phases/01-audio-and-storage-pipeline/01-RESEARCH.md
@.planning/phases/01-audio-and-storage-pipeline/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Player module with AudioContext singleton and per-tile playback</name>
  <files>
    src/audio/player.ts
  </files>
  <action>
Create `src/audio/player.ts` implementing the complete audio playback system.

**Critical iOS Safari constraints to implement (from research):**
1. ONE AudioContext for the entire app lifetime — Safari hard-limits at 4 instances
2. `AudioContext` is created lazily (NOT on module load) — Safari suspends contexts created outside a user gesture
3. `resume()` must be called inside EVERY user tap handler before any audio operation — Safari silently produces no audio if skipped
4. `AudioBufferSourceNode` is single-use — create a new one for each playback; reuse the underlying `AudioBuffer`
5. Interrupted state (phone call, backgrounding): do NOT auto-resume; wait for next user tap (the "resume on every tap" pattern handles this naturally)
6. `decodeAudioData`: use the Promise form, not the legacy callback form

**Locked playback decisions (from CONTEXT.md):**
- Multiple sounds CAN play in parallel across tiles — tapping tile 2 while tile 1 is playing does NOT stop tile 1
- Re-tapping the SAME tile stops it and restarts from the beginning (PLAY-02)
- Sound plays to completion → tile returns to filled/idle state (via onEnded callback)
- Defective blob: throw the error (caller shows message, does NOT delete the blob from storage)

**AudioBuffer caching decision (Claude's discretion):**
Decode on first play, cache resulting AudioBuffer per slot in a Map. This balances startup speed (don't pre-load all 9 clips) and repeat-play latency (no re-decode after first play).

```typescript
// One shared AudioContext for the entire app.
// Safari hard-limits at 4 AudioContext instances — never create more than one.
// Lazy init: creating at module load causes Safari suspension.
let audioContext: AudioContext | null = null;

export function getAudioContext(): AudioContext {
  if (!audioContext) {
    audioContext = new AudioContext();
    // statechange fires as 'interrupted' during phone calls or app backgrounding.
    // We do NOT auto-resume from interruption — the next user tap calls resume() naturally.
    audioContext.addEventListener('statechange', () => {
      // Intentional no-op: state logged for debugging, auto-resume is an anti-pattern on iOS.
      // The "resume on every tap" pattern in ensureAudioContextRunning() handles recovery.
    });
  }
  return audioContext;
}

/**
 * Call at the START of every user tap handler, before any audio operation.
 * iOS Safari silently produces no audio (no error) if the AudioContext is suspended
 * and resume() was not called inside the user gesture handler.
 * This also recovers from 'interrupted' state after phone calls or backgrounding.
 */
export async function ensureAudioContextRunning(): Promise<void> {
  const ctx = getAudioContext();
  if (ctx.state !== 'running') {
    await ctx.resume();
  }
}

// ------- Per-tile playback management -------

// Track the active AudioBufferSourceNode per tile.
// Supports stop-and-restart for the same tile (PLAY-02) while allowing
// parallel playback across different tiles (locked decision).
const activeNodes = new Map<number, AudioBufferSourceNode>();

// AudioBuffer cache: decode on first play, reuse on subsequent plays.
// Avoids re-decoding the same blob repeatedly (decode takes ~10-50ms).
// Cache is keyed by tile index — cleared when a tile's recording is deleted or replaced.
const audioBufferCache = new Map<number, AudioBuffer>();

/**
 * Play the audio blob for the given tile.
 * Stops any existing playback for THIS tile (but not other tiles — parallel playback).
 * Caches the decoded AudioBuffer for repeat plays.
 * Throws if decodeAudioData fails — caller shows error message and KEEPS the blob.
 *
 * MUST call ensureAudioContextRunning() before this in the tap handler.
 */
export async function playBlob(
  tileIndex: number,
  blob: Blob,
  onEnded: () => void,
): Promise<void> {
  const ctx = getAudioContext();

  // Stop existing playback for THIS tile only (PLAY-02: stop and restart on re-tap).
  // Other tiles continue playing — parallel playback is the locked behavior.
  stopTile(tileIndex);

  // Decode the blob to an AudioBuffer (or reuse cached result).
  // decodeAudioData can throw on defective blobs (Pitfall 7).
  // We let the error propagate — caller is responsible for showing error message
  // and must NOT delete the blob from storage (per CONTEXT.md locked decision).
  let audioBuffer = audioBufferCache.get(tileIndex);
  if (!audioBuffer) {
    const arrayBuffer = await blob.arrayBuffer();
    // Promise form of decodeAudioData (not the legacy callback form — see research).
    audioBuffer = await ctx.decodeAudioData(arrayBuffer);
    audioBufferCache.set(tileIndex, audioBuffer);
  }

  // AudioBufferSourceNode is single-use by design — create a new one each play.
  // The AudioBuffer itself is reused (from cache above).
  const source = ctx.createBufferSource();
  source.buffer = audioBuffer;
  source.connect(ctx.destination);

  source.onended = () => {
    // Clean up only if this node is still the active one.
    // If stopTile() was called (re-tap), activeNodes already deleted this entry —
    // onEnded should not fire the "tile → idle" callback in that case.
    if (activeNodes.get(tileIndex) === source) {
      activeNodes.delete(tileIndex);
      onEnded(); // Tile returns to filled/idle state (played to completion)
    }
  };

  activeNodes.set(tileIndex, source);
  source.start(0); // Start immediately
}

/**
 * Stop playback for a specific tile. Safe to call when tile is not playing.
 * Does NOT affect playback on other tiles.
 */
export function stopTile(tileIndex: number): void {
  const existing = activeNodes.get(tileIndex);
  if (existing) {
    try {
      existing.stop();
    } catch {
      // AudioBufferSourceNode.stop() throws if the node has already stopped naturally.
      // This is safe to ignore — the node is already done.
    }
    activeNodes.delete(tileIndex);
  }
}

/**
 * Clear the AudioBuffer cache for a specific tile.
 * Call when a tile's recording is deleted or replaced (the old AudioBuffer is stale).
 */
export function clearAudioCache(tileIndex: number): void {
  audioBufferCache.delete(tileIndex);
}
```

Ensure the file compiles with `strict: true`. No `any` types. No external imports (only browser APIs).
  </action>
  <verify>
Run from /Users/rotmanov/git/private/soundboard:
```bash
npm run build
```
Build must complete with zero TypeScript errors. Confirm:
```bash
ls src/audio/player.ts
```
  </verify>
  <done>
`npm run build` exits 0. `src/audio/player.ts` exists and exports `getAudioContext`, `ensureAudioContextRunning`, `playBlob`, `stopTile`, `clearAudioCache`. No TypeScript errors. No `any` types. No external library imports (browser-native APIs only).
  </done>
</task>

</tasks>

<verification>
1. `npm run build` exits 0
2. `src/audio/player.ts` exports: `getAudioContext`, `ensureAudioContextRunning`, `playBlob`, `stopTile`, `clearAudioCache`
3. AudioContext is created lazily inside `getAudioContext()` — NOT at module load
4. `ensureAudioContextRunning()` calls `ctx.resume()` when state is not 'running'
5. `stopTile()` only stops the specified tile — the `activeNodes` Map tracks per-tile nodes
6. `playBlob()` calls `stopTile(tileIndex)` before starting new playback (stops same tile, not others)
7. AudioBuffer cache (`audioBufferCache` Map) is keyed by tileIndex
8. `decodeAudioData` uses the Promise form (not callbacks)
9. No `any` types; strict TypeScript
</verification>

<success_criteria>
- Player module compiles cleanly under strict TypeScript
- One AudioContext singleton, lazy-initialized, never recreated
- ensureAudioContextRunning() is designed to be called before every audio operation in tap handlers
- Parallel playback is preserved: stopTile() only affects the specified tile
- PLAY-02 (re-tap stops and restarts) is implemented via stopTile() before new start
- AudioBuffer is decoded once and cached; cache entry cleared via clearAudioCache()
- decodeAudioData failure propagates to caller (who shows error, keeps blob)
</success_criteria>

<output>
After completion, create `.planning/phases/01-audio-and-storage-pipeline/01-03-SUMMARY.md` documenting:
- All exported symbols and their signatures
- How activeNodes and audioBufferCache Maps are managed
- AudioContext lifecycle (lazy init, statechange handler behavior)
- Any deviations from the plan
</output>
