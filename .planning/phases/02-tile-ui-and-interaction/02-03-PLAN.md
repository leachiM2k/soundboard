---
phase: 02-tile-ui-and-interaction
plan: "03"
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/ui/action-sheet.ts
  - src/ui/rename-dialog.ts
  - src/storage/db.ts
  - src/state/store.ts
  - src/main.ts
autonomous: true
requirements: [MGMT-01, MGMT-02, PLAY-03]

must_haves:
  truths:
    - "Long-pressing a filled tile opens the iOS action sheet from the bottom"
    - "Action sheet shows Re-record first, Rename second, Delete (red) third, Cancel last"
    - "Delete immediately removes the recording and returns the tile to empty state"
    - "Re-record triggers the recording flow on the long-pressed tile"
    - "Rename opens a dialog with an input field pre-populated with the current label"
    - "A renamed label persists in IndexedDB and survives app restart"
    - "Tapping any tile fires triggerHaptic()"
    - "Recording timer shows elapsed (count-up) and remaining (count-down from 30s) on the recording tile"
    - "The app renders the 3x3 grid on load with recordings restored from IndexedDB"
  artifacts:
    - path: "src/ui/action-sheet.ts"
      provides: "showActionSheet(index, tile, callbacks) — shows modal, wires buttons"
      exports: ["showActionSheet"]
    - path: "src/ui/rename-dialog.ts"
      provides: "showRenameDialog(currentName) => Promise<string|null>"
      exports: ["showRenameDialog"]
    - path: "src/main.ts"
      provides: "Full app bootstrap: initGrid, loadAllSlots, handleTileTap, handleLongPress, recording timer"
      min_lines: 120
  key_links:
    - from: "src/main.ts"
      to: "src/ui/grid.ts"
      via: "imports initGrid, updateTile, updateAllTiles"
      pattern: "import.*initGrid.*from.*grid"
    - from: "src/main.ts"
      to: "src/ui/haptic.ts"
      via: "calls triggerHaptic() in tap handler"
      pattern: "triggerHaptic"
    - from: "src/ui/action-sheet.ts"
      to: "index.html"
      via: "references #action-sheet dialog element"
      pattern: "action-sheet"
    - from: "src/ui/rename-dialog.ts"
      to: "index.html"
      via: "references #rename-dialog dialog element"
      pattern: "rename-dialog"
    - from: "src/main.ts"
      to: "src/storage/db.ts"
      via: "calls saveSlot with updated SlotRecord including label"
      pattern: "saveSlot"
---

<objective>
Wire everything together: action sheet, rename dialog, and the final main.ts that drives the full interactive app.

Purpose: Plans 01 and 02 created all the primitives and visual layer. This plan creates the remaining UI modules and rewrites main.ts to be the complete, production-quality app entry point. After this plan, the app is feature-complete for Phase 2.
Output: action-sheet.ts, rename-dialog.ts (new); main.ts (rewritten); db.ts + store.ts (minor duration field addition).
</objective>

<execution_context>
@/Users/rotmanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rotmanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-tile-ui-and-interaction/02-RESEARCH.md
@.planning/phases/02-tile-ui-and-interaction/02-CONTEXT.md
@.planning/phases/02-tile-ui-and-interaction/02-01-SUMMARY.md
@.planning/phases/02-tile-ui-and-interaction/02-02-SUMMARY.md
@src/audio/recorder.ts
@src/audio/player.ts
@src/storage/db.ts
@src/state/store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create action-sheet.ts and rename-dialog.ts</name>
  <files>src/ui/action-sheet.ts, src/ui/rename-dialog.ts</files>
  <action>
    **src/ui/action-sheet.ts**

    Implement an iOS-style action sheet using the `<dialog id="action-sheet">` element from index.html.

    ```typescript
    import { formatDuration } from './tile';

    export interface ActionSheetCallbacks {
      onReRecord: () => void;
      onRename: () => void;
      onDelete: () => void;
    }

    /**
     * Show the action sheet for a filled tile.
     * Header shows: label (if set) OR "Tile N · M:SS" if no label.
     * Button order (iOS HIG): Re-record, Rename, [spacer], Delete (destructive), Cancel.
     *
     * CRITICAL: Clone buttons before wiring to remove stale listeners from previous opens.
     * CRITICAL: Close on backdrop click (click on dialog element itself, not content).
     */
    export function showActionSheet(
      index: number,
      label: string | undefined,
      durationSeconds: number | undefined,
      callbacks: ActionSheetCallbacks,
    ): void {
      const dialog = document.getElementById('action-sheet') as HTMLDialogElement;
      const header = document.getElementById('action-sheet-header');

      // Set header text
      if (header) {
        if (label) {
          header.textContent = label;
        } else if (durationSeconds != null) {
          header.textContent = `Kachel ${index + 1} · ${formatDuration(durationSeconds)}`;
        } else {
          header.textContent = `Kachel ${index + 1}`;
        }
      }

      // Wire buttons — replace each button with a clone to drop stale listeners
      function wireBtn(id: string, handler: () => void) {
        const btn = document.getElementById(id);
        if (!btn) return;
        const clone = btn.cloneNode(true) as HTMLButtonElement;
        btn.replaceWith(clone);
        clone.addEventListener('click', () => {
          dialog.close();
          handler();
        });
      }

      wireBtn('btn-rerecord', callbacks.onReRecord);
      wireBtn('btn-rename', callbacks.onRename);
      wireBtn('btn-delete', callbacks.onDelete);
      wireBtn('btn-cancel', () => {}); // cancel just closes

      // Close on backdrop click (Pitfall 6 from research)
      const onDialogClick = (e: MouseEvent) => {
        if (e.target === dialog) {
          dialog.close();
          dialog.removeEventListener('click', onDialogClick);
        }
      };
      dialog.addEventListener('click', onDialogClick);

      // Clean up backdrop listener when dialog closes for any reason
      dialog.addEventListener('close', () => {
        dialog.removeEventListener('click', onDialogClick);
      }, { once: true });

      dialog.showModal();
    }
    ```

    **src/ui/rename-dialog.ts**

    Implement the rename dialog using `<dialog id="rename-dialog">` from index.html.

    ```typescript
    /**
     * Show the rename dialog pre-populated with currentName.
     * Returns the trimmed new name, or null if user cancelled.
     *
     * Uses custom <dialog> instead of window.prompt() — window.prompt has
     * known reliability issues in iOS standalone PWA mode and cannot be styled.
     *
     * Focus is delayed via requestAnimationFrame to work around iOS Safari
     * keyboard timing (keyboard won't appear if focus fires synchronously during showModal).
     */
    export function showRenameDialog(currentName: string): Promise<string | null> {
      return new Promise((resolve) => {
        const dialog = document.getElementById('rename-dialog') as HTMLDialogElement;
        const input = document.getElementById('rename-input') as HTMLInputElement;
        const form = document.getElementById('rename-form') as HTMLFormElement;
        const cancelBtn = document.getElementById('rename-cancel') as HTMLButtonElement;

        input.value = currentName;

        function handleSubmit(e: SubmitEvent) {
          e.preventDefault();
          const value = input.value.trim();
          dialog.close();
          cleanup();
          resolve(value || null);
        }

        function handleCancel() {
          dialog.close();
          cleanup();
          resolve(null);
        }

        function handleEsc() {
          // 'cancel' event fires on ESC key press
          cleanup();
          resolve(null);
        }

        function cleanup() {
          form.removeEventListener('submit', handleSubmit);
          cancelBtn.removeEventListener('click', handleCancel);
          dialog.removeEventListener('cancel', handleEsc);
        }

        form.addEventListener('submit', handleSubmit);
        cancelBtn.addEventListener('click', handleCancel);
        dialog.addEventListener('cancel', handleEsc, { once: true });

        dialog.showModal();

        // Delay focus: iOS Safari keyboard won't show if focus fires synchronously
        requestAnimationFrame(() => {
          input.focus();
          input.select(); // pre-select existing name for easy replacement
        });
      });
    }
    ```
  </action>
  <verify>
    Run: `npx tsc --noEmit` — must exit 0.
    Confirm action-sheet.ts exports `showActionSheet` and rename-dialog.ts exports `showRenameDialog`.
  </verify>
  <done>Both dialog modules compile clean. showActionSheet wires buttons with clone pattern. showRenameDialog returns Promise resolving to string or null. Backdrop click closes action sheet.</done>
</task>

<task type="auto">
  <name>Task 2: Add durationSeconds to SlotRecord and rewrite main.ts</name>
  <files>src/storage/db.ts, src/state/store.ts, src/main.ts</files>
  <action>
    **src/storage/db.ts** — add `durationSeconds?: number` to SlotRecord:
    ```typescript
    export interface SlotRecord {
      blob: Blob;
      mimeType: string;
      recordedAt: number;       // Unix timestamp at save time
      durationSeconds?: number; // Elapsed recording time in seconds (added Phase 2)
      label?: string;           // User-customizable tile name (added Phase 2, from Plan 01)
    }
    ```
    No other changes. Backward compatible — existing records without durationSeconds read as undefined.

    **src/state/store.ts** — no changes needed (label already added in Plan 01, durationSeconds lives on SlotRecord).

    **src/main.ts** — completely rewrite with the full Phase 2 app:

    The rewrite must:
    1. Import from all Phase 1 modules (format, recorder, player, db) unchanged
    2. Import from Phase 2 modules: initGrid, updateTile, updateAllTiles (grid.ts), triggerHaptic (haptic.ts), showActionSheet (action-sheet.ts), showRenameDialog (rename-dialog.ts)
    3. Import transitionTile, createAppState, AppState from store.ts
    4. Import SlotIndex, loadAllSlots, saveSlot, deleteSlot, loadSlot from db.ts
    5. Import startRecordingTimer from a new inline helper OR implement inline

    **Recording timer:** Implement the timer inline in main.ts (not a separate file). The research's `startRecordingTimer` pattern:
    ```typescript
    let _recordingTimer: ReturnType<typeof setInterval> | null = null;

    function startRecordingTimer(index: number): () => void {
      const startTime = Date.now();
      const MAX_SECONDS = 30;
      _recordingTimer = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const remaining = Math.max(0, MAX_SECONDS - elapsed);
        const elapsedEl = document.getElementById(`timer-elapsed-${index}`);
        const remainingEl = document.getElementById(`timer-remaining-${index}`);
        if (elapsedEl) elapsedEl.textContent = formatTimerDisplay(elapsed);
        if (remainingEl) remainingEl.textContent = `0:${String(remaining).padStart(2, '0')}`;
      }, 200);

      return () => {
        if (_recordingTimer !== null) {
          clearInterval(_recordingTimer);
          _recordingTimer = null;
        }
      };
    }

    function formatTimerDisplay(seconds: number): string {
      const m = Math.floor(seconds / 60);
      const s = seconds % 60;
      return `${m}:${s.toString().padStart(2, '0')}`;
    }
    ```

    **handleTileTap** must:
    - Call `triggerHaptic()` immediately (inside user gesture, before any await)
    - Call `requestStoragePersistence()` and `ensureAudioContextRunning()` (order from Phase 1)
    - Dispatch on tile.state — same logic as Phase 1 main.ts with these Phase 2 additions:
      - In `empty` case: track recording start time; in `onComplete`, compute `durationSeconds` and pass to `saveSlot`; call `stopRecordingTimer()` before transitioning to saving
      - In `recording` case: call `stopRecordingTimer()` before transitioning
      - In `error` case (has record): now IS a no-op still (long-press re-record handles this, same as Phase 1)

    **handleLongPress(index)** must:
    - Only act if tile.state is 'has-sound', 'playing', or 'error' (has a record)
    - Call `showActionSheet(index, tile.label, record.durationSeconds, { onReRecord, onRename, onDelete })`
    - `onReRecord`: transition tile to empty, then call `handleTileTap(index)` (same as error retry pattern from Phase 1)
    - `onDelete`: call `deleteSlot(index)`, `clearAudioCache(index)`, transition tile to empty, call `updateTile(index, appState.tiles[index])`
    - `onRename`: call `showRenameDialog(tile.label ?? '')`. If result is not null, update `tile.label` on TileData AND save updated record to IndexedDB (load current record, add label, saveSlot). Then call `updateTile(index, appState.tiles[index])`.

    **Rename persistence detail:**
    ```typescript
    async function handleRename(index: SlotIndex): Promise<void> {
      const tile = appState.tiles[index];
      const newLabel = await showRenameDialog(tile.label ?? '');
      if (newLabel === null) return; // user cancelled
      tile.label = newLabel || undefined; // clear empty string to undefined
      // Persist label to IndexedDB
      const record = await loadSlot(index);
      if (record) {
        await saveSlot(index, { ...record, label: tile.label });
      }
      updateTile(index, tile);
    }
    ```

    **Bootstrap (DOMContentLoaded)**:
    ```typescript
    document.addEventListener('DOMContentLoaded', () => {
      loadAllSlots()
        .then((slots) => {
          slots.forEach((record, index) => {
            if (record) {
              const tile = transitionTile(appState, index, 'has-sound', { record });
              tile.label = record.label; // restore persisted label
            }
          });
          initGrid(
            appState,
            (index) => {
              handleTileTap(index as SlotIndex).catch((err: unknown) => {
                console.error('Unhandled tap error:', err);
              });
            },
            (index) => {
              handleLongPress(index as SlotIndex).catch((err: unknown) => {
                console.error('Unhandled long-press error:', err);
              });
            },
          );
        })
        .catch((err: unknown) => {
          console.error('Failed to load slots:', err);
          initGrid(appState, ...); // still initialize grid even if load fails
        });
    });
    ```

    **CRITICAL implementation notes:**
    - `triggerHaptic()` MUST be called BEFORE any `await` in `handleTileTap` — iOS requires user gesture synchronously, and awaiting anything (even a resolved promise) breaks the gesture context.
    - Use `updateTile(index, appState.tiles[index])` after every `transitionTile()` call. Do NOT use a global `updateAllTiles()` after every state change — it is inefficient and causes unnecessary DOM updates.
    - The `onComplete` callback from `startRecording()` closes over `recordStartTime` (a local variable set when recording starts) to compute elapsed seconds: `const durationSeconds = Math.round((Date.now() - recordStartTime) / 1000)`.
    - Carry `record` reference through `playing` state by storing it on TileData (same pattern as Phase 1 main.ts).
    - `clearAudioCache` is imported from player.ts — it clears the AudioBuffer cache for the tile's index.
    - Do NOT import RECORDING_MIME_TYPE if it's only used for a console.log — omit the debug log in the production rewrite.
  </action>
  <verify>
    Run: `npx tsc --noEmit` — must exit 0.
    Run: `npm run build` — Vite must bundle cleanly with no errors.
    Run: `npm run dev -- --host` and open in browser — 9 tiles must appear in the 3x3 grid.
    Click any tile — haptic (on device) should fire; empty tile should enter recording state with timer displayed; clicking again should stop recording.
  </verify>
  <done>
    - `npx tsc --noEmit` exits 0
    - `npm run build` succeeds
    - App loads showing 9 tiles in 3x3 grid
    - Tap handler calls triggerHaptic() before any await
    - Recording timer counts up/down on recording tile
    - Long-press on filled tile shows action sheet with Re-record/Rename/Delete/Cancel
    - Delete removes recording and returns tile to empty
    - Rename persists to IndexedDB
    - Phase 1 audio behaviour (record, play, restart, auto-stop) still works
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `npx tsc --noEmit` exits 0
2. `npm run build` succeeds
3. Opening the app in browser shows 9 dark empty tiles in a 3x3 grid filling the viewport
4. Clicking an empty tile starts recording (tile turns dark with red border + pulsing animation, timer shows)
5. Clicking recording tile stops and saves (tile dims briefly, then shows play icon + label)
6. Clicking filled tile plays audio (tile brightens)
7. Long-pressing a filled tile opens action sheet from bottom
8. Tapping Delete in action sheet returns tile to empty state
9. Tapping Rename opens rename dialog, entering text and saving updates tile label
10. App restart restores all tiles and labels from IndexedDB
</verification>

<success_criteria>
Complete Phase 2 feature set implemented: 3x3 grid, tile visual states, pulse animation, haptic feedback, recording timer, long-press action sheet, delete, re-record, rename with persistence. All Phase 2 requirements (GRID-01, GRID-02, REC-03, MGMT-01, MGMT-02, PLAY-03) implemented and verified locally. Ready for iPhone Safari verification in Plan 04.
</success_criteria>

<output>
After completion, create `.planning/phases/02-tile-ui-and-interaction/02-03-SUMMARY.md` using the summary template.
</output>
